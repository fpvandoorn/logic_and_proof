<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2015-09-03 Thu 18:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Logic and Proof</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://https://www.andrew.cmu.edu/user/rlewis1/][Robert Y. Lewis]]Robert Y. Lewis,  [[http://http://www.contrib.andrew.cmu.edu/~fpv/][Floris van Doorn]]Floris van Doorn" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/polymer.platform/0.4.2/platform.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
</head>
<body>
<div id="content">
<h1 class="title">Logic and Proof</h1>

<div id="outline-container-orgheadline16" class="outline-2">
<h2 id="Propositional_Logic"><a id="orgheadline16"></a><span class="section-number-2"> 2</span> Propositional Logic</h2>
<div class="outline-text-2" id="text-Propositional_Logic">
</div>

<div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3"> 2.1</span> A Puzzle</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The following puzzle, titled "Malice and Alice," is from George
J. Summers' <i>Logical Deduction Puzzles</i>.
</p>
<hr  />
<p>
Alice, Alice's husband, their son, their daughter, and Alice's brother
were involved in a murder. One of the five killed one of the other
four. The following facts refer to the five people mentioned:
</p>

<ol class="org-ol">
<li>A man and a woman were together in a bar at the time of the murder.</li>
<li>The victim and the killer were together on a beach at the time of
the murder.</li>
<li>One of Alice's two children was alone at the time of the murder.</li>
<li>Alice and her husband were not together at the time of the murder.</li>
<li>The victim's twin was not the killer.</li>
<li>The killer was younger than the victim.</li>
</ol>

<p>
Which one of the five was the victim?
</p>
<hr  />

<p>
Take some time to try to work out a solution. (You should assume that
the victim's twin is one of the five people mentioned.) Summers' book
offers the following hint: "First find the locations of two pairs of
people at the time of the murder, and then determine who the killer
and the victim were so that no condition is contradicted."
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3"> 2.2</span> A Solution</h3>
<div class="outline-text-3" id="text-1-2">
<p>
If you have worked on the puzzle, you may have noticed a few
things. First, it is helpful to draw a diagram, and to be systematic
about searching for an answer. The number of characters, locations,
and attributes is finite, so that there are only finitely many
possible "states of affairs" that need to be considered. The numbers
are also small enough so that systematic search through all the
possibilities, though tedious, will eventually get you to the right
answer. This is a special feature of logic puzzles like this; you
would not expect to show, for example, that every even number greater
than two can be written as a sum of primes by running through all the
possibilities.
</p>

<p>
Another thing that you may have noticed is that the question seems to
presuppose that there is a unique answer to the question, which is to
say, of all the states of affairs that meet the list of conditions,
there is only one person who can possibly be the killer. <i>A priori</i>,
without that assumption, there is a difference between finding <i>some</i>
person who could have been the victim, and show that that person <i>had</i>
to be the victim. In other words, there is a difference between
exhibiting some state of affairs that meets the criteria, and
demonstrating conclusively that no other solution is possible.
</p>

<p>
The published solution in the book not only produces a state of
affairs that meets the criterion, but at the same time proves that
this is the only one that does so. It is quoted below, in full.
</p>

<hr  />
<p>
From <code>[1]</code>, <code>[2]</code>, and <code>[3]</code>, the roles of the five people were as
follows: Man and Woman in the bar, Killer and Victim on the beach, and
Child alone.
</p>

<p>
Then, from <code>[4]</code>, either Alice's husband was in the bar and Alice was
on the beach, or Alice was in the bar and Alice's husband was on the
beach.
</p>

<p>
If Alice's husband was in the bar, the woman he was with was his
daughter, the child who was alone was his son, and Alice and her
brother were on the beach. Then either Alice or her brother was the
victim; so the other was the killer. But, from <code>[5]</code>, the victim had a
twin, and this twin was innocent. Since by Alice and her brother could
only be twins to each other, this situation is impossible. Therefore
Alice's husband was not in the bar.
</p>

<p>
So Alice was in the bar. If Alice was in the bar, she was with her
brother or her son.
</p>

<p>
If Alice was with her brother, her husband was on the beach with one
of the two children. From <code>[5]</code>, the victim could not be her husband,
because none of the others could be his twin; so the killer was her
husband and the victim was the child he was with. But this situation
is impossible, because it contradicts <code>[6]</code>. Therefore, Alice was not
with her brother in the bar.
</p>

<p>
So Alice was with her son in the bar. Then the child who was alone was
her daughter. Therefore, Alice's husband was with Alice's brother on
the beach. From previous reasoning, the victim could not be Alice's
husband. But the victim could be Alice's brother because Alice could
be his twin. 
</p>

<p>
So <i>Alice's brother was the victim</i> and Alice's husband was the
killer.
</p>
<hr  />

<p>
This argument relies on some "extra logical" elements, for example,
that a father cannot be younger than his child, and that a parent and
his or her child cannot be twins. But the argument also involves a
number of common logical terms and associated patterns of
inference. In the next section, we will focus on some of the rules
governing the terms "and," "or," "not," and "if &#x2026; then." Following
the model described in the introduction, each such construction will
be analyzed in three ways:
</p>
<ul class="org-ul">
<li>with examples of the way it is used and employed in informal
(mathematical) arguments</li>
<li>with a formal, symbolic representation</li>
<li>with an implementation in <i>Lean</i></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3"> 2.3</span> Rules of Inference</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3"><span class="section-number-4"> 2.3.1</span> Implication</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
The first pattern of reasoning we will discuss, involving the "if
&#x2026; then &#x2026;" construct, can be hard to discern. Its use is largely
implicit in the solution above. The inference in the fourth paragraph,
spelled out in greater detail, runs as follows:
</p>

<hr  />
<p>
If Alice was in the bar, Alice was with her brother or son.
</p>

<p>
Alice was in the bar.
</p>

<p>
Alice was with her brother or son.
</p>
<hr  />

<p>
This rule is sometimes known as <i>modus ponens</i>, or "implication
elimination," since it tells us how to use an implication in an
argument. In a system of natural deduction, it is expressed as
follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_46e555e7ba4fd0b0cb485c3438348fc25fca3f7d.png" alt="\begin{center}
\AXM{A \to B}
\AXM{A}
\RL{$\mathord{\to}\mathrm{E}$}
\BIM{B}
\DP
\end{center}
" /></p>
</div>
<p>
Read this as saying that if you have a proof of <img src="ltxpng/02_Propositional_Logic.org.temp_3a9090234befeadc30f2545de2a44cc4fe6badf4.png" alt="$A \to B$" />, possibly
from some hypotheses, and a proof of <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />, possibly from hypotheses,
then combining these yields a proof of <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />, from the hypotheses in
both subproofs.
</p>

<p>
In Lean, the inference is expressed as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-1' mode="ace/mode/lean" readonly="true">variables (A B : Prop)
premises (H₁ : A → B) (H₂ : A)

example : B := 
show B, from H₁ H₂
</juicy-ace-editor><div id='lean-full-code-1' style='display:none'>variables (A B : Prop)
premises (H₁ : A → B) (H₂ : A)

example : B := 
show B, from H₁ H₂
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-1').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The first command declares two variables, <code>A</code> and <code>B</code>, ranging over
propositions. The second line introduces two premises, namely, <code>A → B</code>
and <code>A</code>. The next line asserts, as an example, that <code>B</code> follows from
the premises. The proof is written simply <code>H₁ H₂</code>: think of this as
the premise <code>H₁</code> "applied to" the premise <code>H₂</code>. 
</p>

<p>
You can enter the arrow by writing <code>\to</code> or <code>\imp</code> or <code>\r</code>. You can
enter <code>H₁</code> by typing <code>H\_1</code>. You can use any reasonable alphanumeric
identifier for a hypothesis; the letter "H" is a conventional choice.
The identifier <code>H1</code> is a different from <code>H₁</code>, but you can also use
that, if you prefer.
</p>

<p>
The rule for proving an "if &#x2026; then" statement is more
subtle. Consider the beginning of the third paragraph, which argues
that if Alice's husband was in the bar, then Alice or her brother
was the victim. Abstracting away some of the details, the argument has
the following form:
</p>

<hr  />
<p>
Suppose Alice's husband was in the bar.
</p>

<p>
Then &#x2026;
</p>

<p>
Then &#x2026;
</p>

<p>
Then Alice or her brother was the victim.
</p>

<p>
Thus, if Alice's husband was in the bar, then Alice or her brother was the 
victim.
</p>
<hr  />
<p>
This is a form of <i>hypothetical reasoning</i>. On the supposition that
<img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> holds, we argue that <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> holds as well. If we are successful, we
have shown that <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> implies <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />, without supposing <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />. In other
words, the temporary assumption that <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> holds is "canceled" by making
it explicit in the conclusion.
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_55e5ac0cf10ba75ee0d59a58ce29df9596557280.png" alt="\begin{center}
\AXM{}
\UIM{H : A}
\noLine
\UIM{\vdots}
\noLine
\UIM{B}
\RL{$\mathord{\to}\mathrm{I}, H$}
\UIM{A \to B}
\DP
\end{center}
" /></p>
</div>
<p>
The hypothesis is given the label <img src="ltxpng/02_Propositional_Logic.org.temp_5036dd76902b97a998bc024eb115e3b1e701dbb8.png" alt="$H$" />; when the introduction rule is
applied, the label <img src="ltxpng/02_Propositional_Logic.org.temp_5036dd76902b97a998bc024eb115e3b1e701dbb8.png" alt="$H$" /> indicates the relevant hypothesis. The line
over the hypothesis indicates that the assumption has been "canceled"
by the introduction rule.
</p>

<p>
In Lean, this inference takes the following form:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : A → B :=
assume H : A,
show B, from sorry
</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>variables (A B : Prop)

example : A → B :=
assume H : A,
show B, from sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>
<p>
To prove <code>A → B</code>, we assume <code>A</code>, with label <code>H</code>, and show <code>B</code>. Here,
the word <code>sorry</code> indicates that the proof is omitted. In this case,
this is necessary; since <code>A</code> and <code>B</code> are arbitrary propositions, there
is no way to prove <code>B</code> from <code>A</code>. In general, though, <code>A</code> and <code>B</code> will
be compound expressions, and you are free to use the hypothesis <code>H :
A</code> to prove <code>B</code>.
</p>

<p>
Using <code>sorry</code>, we can illustrate the implication elimination rule
alternatively as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : B :=
have H₁ : A → B, from sorry,
have H₂ : A, from sorry,
show B, from H₁ H₂
</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>variables (A B : Prop)

example : B :=
have H₁ : A → B, from sorry,
have H₂ : A, from sorry,
show B, from H₁ H₂
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We will adopt this convention below, using <code>sorry</code> to stand for parts
of a proof that could be spelled out, when the variables involved are
replaced by more complex assertions.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4"> 2.3.2</span> Conjunction</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
As was the case for implication, other logical connectives are
generally characterized by their <i>introduction</i> and <i>elimination</i>
rules. An introduction rule shows how to establish a claim involving
the connective, while an elimination rule shows how to use such a
statement that contains the connective to derive others.
</p>

<p>
Let us consider, for example, the case of conjunction, that is, the
word "and." Informally, we establish a conjunction by establishing
each conjunct. For example, informally we might argue:
</p>
<hr  />
<p>
Alice's brother was the victim.
</p>

<p>
Alice's husband was the killer.
</p>

<p>
Therefore Alice's brother was the victim and Alice's husband was the
killer.
</p>
<hr  />
<p>
The inference seems almost too obvious to state explicitly, since the
word "and" simply combines the two assertions into one. Informal
proofs often downplay the distinction. In natural deduction, the rule
reads as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_e9d7aa9ab635288efefe04fab432a2a0c8c41cde.png" alt="\begin{center}
\AXM{A}
\AXM{B}
\RL{$\mathord{\wedge}\mathrm{I}$}
\BIM{A \wedge B}
\DP
\end{center}
" /></p>
</div>
<p>
In Lean, the rule is denoted <code>and.intro</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : A ∧ B :=
have H₁ : A, from sorry,
have H₂ : B, from sorry,
show A ∧ B, from and.intro H₁ H₂
</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>variables (A B : Prop)

example : A ∧ B :=
have H₁ : A, from sorry,
have H₂ : B, from sorry,
show A ∧ B, from and.intro H₁ H₂
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You can enter the wedge symbol by typing <code>\and</code>.
</p>

<p>
The two elimination rules allow us to extract the two components:
</p>
<hr  />
<p>
Alice's husband was in the bar and Alice was on the beach.
</p>

<p>
So Alice's husband was in the bar.
</p>
<hr  />
<p>
Or:
</p>
<hr  />
<p>
Alice's husband was in the bar and Alice was on the beach.
</p>

<p>
So Alice's was on the beach.
</p>
<hr  />
<p>
In natural deduction, these patterns are rendered as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_4163d798cb8693449cd79dd382e2644b4b647154.png" alt="\begin{center}
\AXM{A \wedge B}
\RL{$\mathord{\land}\mathrm{E_1}$}
\UIM{A}
\DP
\quad
\AXM{A \wedge B}
\RL{$\mathord{\land}\mathrm{E_2}$}
\UIM{B}
\DP
\end{center}
" /></p>
</div>
<p>
In Lean, the inferences are known as <code>and.left</code> and <code>and.right</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : A :=
have H : A ∧ B, from sorry,
show A, from and.left H

example : B :=
have H : A ∧ B, from sorry,
show B, from and.right H
</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>variables (A B : Prop)

example : A :=
have H : A ∧ B, from sorry,
show A, from and.left H

example : B :=
have H : A ∧ B, from sorry,
show B, from and.right H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4"> 2.3.3</span> Negation and Falsity</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
In logical terms, showing "not A" amounts to showing that A leads to a
contradiction. For example:
</p>
<hr  />
<p>
Suppose Alice's husband was in the bar. 
</p>

<p>
&#x2026;
</p>

<p>
This situation is impossible. 
</p>

<p>
Therefore Alice's husband was not in the bar.
</p>
<hr  />
<p>
This is another form of hypothetical reasoning, similar to that used
in establishing an "if &#x2026; then" statement: we temporarly assume A,
show that leads to a contradiction, and conclude that "not A"
holds.
</p>

<p>
In natural deduction, the rule reads as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_ff94c0ca008f6e11baef670e87f7e253496279bb.png" alt="\begin{center}
\AXM{}
\UIM{A}
\noLine
\UIM{\vdots}
\noLine
\UIM{\bot}
\RL{$\lnot \mathrm{I}$}
\UIM{\lnot A}
\DP
\end{center}
" /></p>
</div>
<p>
In Lean, it is illustrated by the following:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">variable A : Prop

example : ¬ A :=
assume H : A,
show false, from sorry
</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>variable A : Prop

example : ¬ A :=
assume H : A,
show false, from sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You can enter the negation symbol by typing <code>\not</code>.
</p>

<p>
The elimination rule is dual to these. It expresses that if we have
both "A" and "not A," then we have a contradiction. This pattern is
illustrated in the informal argument below, which is implicit in the
fourth paragraph of the solution to "Malice and Alice."
</p>
<hr  />
<p>
The killer was Alice's husband and the victim was the child he was
with.
</p>

<p>
So the killer was not younger than his victim.
</p>

<p>
But according to <code>[6]</code>, the killer was younger than his victim.
</p>

<p>
This situation is impossible.
</p>
<hr  />
<p>
In symbolic logic, the rule of inference is expressed as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_8b5a7732365a9df58572ccbd050107efc4886936.png" alt="\begin{center}
\AXM{\lnot A}
\AXM{A}
\RL{$\lnot \mathrm{E}$}
\BIM{\bot}
\DP
\end{center}
" /></p>
</div>
<p>
And in Lean, it is implemented in the following way:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">variable A : Prop

example : false :=
have H₁ : ¬ A, from sorry,
have H₂ : A, from sorry,
show false, from H₁ H₂
</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>variable A : Prop

example : false :=
have H₁ : ¬ A, from sorry,
have H₂ : A, from sorry,
show false, from H₁ H₂
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that the negation elimination rule is expressed in a manner
similar to implication elimination: the label asserting the negation
comes first, and by "applying" the proof of the negation to the
proof of the positive fact, we obtain a proof of falsity.
</p>

<p>
Notice also that in the symbolic framework, we have introduced a new
symbol, <img src="ltxpng/02_Propositional_Logic.org.temp_7bea1d03799b42f9b799647895fded7894b866bd.png" alt="$\bot$" />. It corresponds to the identifier <code>false</code> in Lean, and
natural language phrases like "this is a contradiction" or "this is
impossible."
</p>

<p>
What are the rules governing <img src="ltxpng/02_Propositional_Logic.org.temp_7bea1d03799b42f9b799647895fded7894b866bd.png" alt="$\bot$" />? In natural deduction, there is no
introduction rule; "false" is false, and there should be no way to
prove it, other than extract it from contradictory hypotheses. On the
other hand, natural deduction provides a rule that allows us to
conclude anything from a contradiction:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_35288078004ded57eb23278afd8e956911584b5a.png" alt="\begin{center}
\AXM{\bot}
\RL{$\bot \mathrm{E}$}
\UIM{A}
\DP
\end{center}
" /></p>
</div>
<p>
The elimination rule also has the fancy Latin name, <i>ex falso
sequitur quodlibet</i>, which means ``anything you want follows from
falsity.'' In Lean it is implemented as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">variable A : Prop

example : A :=
have H : false, from sorry,
show A, from false.elim H
</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>variable A : Prop

example : A :=
have H : false, from sorry,
show A, from false.elim H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This elimination rule is harder to motivate from a natural language
perspective, but, nonetheless, it is needed to capture common patterns
of inference. One way to understand it is this. Consider the following
statement:
</p>
<hr  />
<p>
For every natural number <img src="ltxpng/02_Propositional_Logic.org.temp_6456f2649ddade5686905f71bd3d22a9376cf8af.png" alt="$n$" />, if <img src="ltxpng/02_Propositional_Logic.org.temp_6456f2649ddade5686905f71bd3d22a9376cf8af.png" alt="$n$" /> is prime and greater than 2, then
<img src="ltxpng/02_Propositional_Logic.org.temp_6456f2649ddade5686905f71bd3d22a9376cf8af.png" alt="$n$" /> is odd.
</p>
<hr  />
<p>
We would like to say that this is a true statement. But if it is true,
then it is true of any particular number <img src="ltxpng/02_Propositional_Logic.org.temp_6456f2649ddade5686905f71bd3d22a9376cf8af.png" alt="$n$" />. Taking <img src="ltxpng/02_Propositional_Logic.org.temp_e62b3f122ad8b60e27eb1c9a46bee4bb6f8ec5d5.png" alt="$n = 2$" />, we have
the statement:
</p>
<hr  />
<p>
If 2 is prime and greater than 2, then 2 is odd.
</p>
<hr  />
<p>
In this conditional statement, both the antecedent and succedent are
false. The fact that we are committed to saying that this statement is
true shows that we should be able to prove, one way or another, that
the statement 2 is odd follows from the false statement that 2 is
prime and greater than 2. The <i>ex falso</i> neatly encapsulates this sort
of inference.
</p>

<p>
Notice that if we define <img src="ltxpng/02_Propositional_Logic.org.temp_c9fc0b9f87a04276e5274737b465662205a69233.png" alt="$\neg A$" /> to be <img src="ltxpng/02_Propositional_Logic.org.temp_9eb1ac6b4f02410feea1ca6215e48d255300a699.png" alt="$A \to \bot$" />, then the rules
for negation introduction and elimination are nothing more than
implication introduction and elimination, respectively. We can think
of <img src="ltxpng/02_Propositional_Logic.org.temp_c9fc0b9f87a04276e5274737b465662205a69233.png" alt="$\neg A$" /> expressed colorfully by saying "if <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> is true, then pigs
have wings," where "pigs have wings" is stands for <img src="ltxpng/02_Propositional_Logic.org.temp_7bea1d03799b42f9b799647895fded7894b866bd.png" alt="$\bot$" />.
</p>

<p>
Having introduced a symbol for "false," it is only fair to introduce a
symbol for "true." In contrast to "false," "true" has no elimination
rule, only an introduction rule:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_1fbd28df5bbd9f5c9b7875218ab23749b79732fd.png" alt="\begin{prooftree}
\AXM{}
\UIM{\top}
\end{prooftree}
" /></p>
</div>
<p>
Put simply, "true" is true. In Lean, we can use <code>true.intro</code> for this
rule, or the abbreviation <code>trivial</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">example : true :=
show true, by trivial
</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>example : true :=
show true, by trivial
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4"> 2.3.4</span> Disjunction</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
The introduction rules for disjunction, otherwise known as "or," are
straightforward. For example, the claim that condition <code>[3]</code> is met in
the proposed solution can be justified as follows:
</p>
<hr  />
<p>
Alice's daughter was alone at the time of the murder.
</p>

<p>
Therefore, either Alice's daughter was alone at the time of the
murder, or Alice's son was alone at the time of the murder.
</p>
<hr  />
<p>
In terms of natural deduction, the two introduction rules are as
follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_91056b621fca4f8d7d22dec2f36b015eedb42cdb.png" alt="\begin{center}
\AXM{A}
\RL{$\mathord{\lor}\mathrm{I_l}$}
\UIM{A \lor B}
\DP
\quad
\AXM{B}
\RL{$\mathord{\lor}\mathrm{I_r}$}
\UIM{A \lor B}
\DP
\end{center}
" /></p>
</div>
<p>
Here, the <img src="ltxpng/02_Propositional_Logic.org.temp_8e7cc17c0678c6cd1ba29f5c0c00a45cbf4af413.png" alt="$l$" /> and <img src="ltxpng/02_Propositional_Logic.org.temp_b643064d0f5fa210f63ec304fb6f3d71fa382d67.png" alt="$r$" /> stand for "left" and "right". In Lean, they are
implemented as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : A ∨ B :=
have H : A, from sorry,
show A ∨ B, from or.inl H

example : A ∨ B :=
have H : B, from sorry,
show A ∨ B, from or.inr H
</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>variables (A B : Prop)

example : A ∨ B :=
have H : A, from sorry,
show A ∨ B, from or.inl H

example : A ∨ B :=
have H : B, from sorry,
show A ∨ B, from or.inr H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You can enter the vee symbol by typing <code>\or</code>. The identifiers <code>inl</code>
and <code>inr</code> stand for "insert left" and "insert right," respectively.
</p>

<p>
The disjunction elimination rule is trickier, but it represents a
natural form of case-based hypothetical reasoning. The instances that
occur in the solution to "Malice and Alice" are all special cases of
this rule, so it will be helpful to make up a new example to
illustrate the general phenomenon. Suppose, in the argument above, we
had established that either Alice's brother or her son was in the bar,
and we wanted to argue for the conclusion that her husband was on the
beach. One option is to argue by cases: first, consider the case that
her brother was in the bar, and argue for the conclusion on the basis
of that assumption; then consider the case that her son was in the
bar, and argue for the same conclusion, this time on the basis of the
second assumption. Since the two cases are exhaustive, if we know that
the conclusion holds in each case, we know that it holds outright. The
pattern looks something like this:
</p>
<hr  />
<p>
Either Alice's brother was in the bar, or Alice's son was in the bar.
</p>

<p>
Suppose, in the first case, that her brother was in the bar. Then
&#x2026; Therefore, her husband was on the beach.
</p>

<p>
On the other hand, suppose her son was in the bar. In that case,
&#x2026; Therefore, in this case also, her husband was on the beach.
</p>

<p>
Either way, we have established that her husband was on the beach.
</p>
<hr  />
<p>
In natural deduction, this pattern is expressed as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_19b386f65fc15fc63ba340f4fe7bf636ff37d26c.png" alt="\begin{center}
\AXM{A \vee B}
\AXM{}
\UIM{A}
\noLine
\UIM{\vdots}
\noLine
\UIM{C}
\AXM{}
\UIM{B}
\noLine
\UIM{\vdots}
\noLine
\UIM{C}
\RL{$\mathord{\lor}\mathrm{E}$}
\TIM{C}
\DP
\end{center}
" /></p>
</div>
<p>
And here it is in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">variables (A B C : Prop)

example : C :=
have H : A ∨ B, from sorry,
show C, from or.elim H
  (assume H₁ : A,
    show C, from sorry)
  (assume H₂ : B,
    show C, from sorry)
</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>variables (A B C : Prop)

example : C :=
have H : A ∨ B, from sorry,
show C, from or.elim H
  (assume H₁ : A,
    show C, from sorry)
  (assume H₂ : B,
    show C, from sorry)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
What makes this pattern confusing is that it requires two instances of
nested hypothetial reasoning: in the first block of parentheses, we
temporarily assume <code>A</code>, and in the second block, we temporarily assume
<code>B</code>. When the dust settles, we have established <code>C</code> outright.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7"><span class="section-number-4"> 2.3.5</span> If and only if</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
In mathematical arguments, it is common to say of two statements, <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />
and <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />, that "<img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> holds if and only if <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> holds." This assertion is
sometimes abbreviated "<img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> iff <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />," and means simply that <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> implies
<img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> and <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> implies <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />. It is not essential that we introduce a new
symbol into our logical language to model this connective, since the
statement can be expressed, as we just did, in terms of "implies" and
"and." But notice that the length of the expression doubles because
<img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> and <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> are each repeated. The logical abbreviation is therefore
convenient, as well as natural.
</p>

<p>
The conditions of "Malice and Alice" imply that Alice is in the bar
if and only if Alice's husband is on the beach. Such a statement is
established by arguing for each implication in turn:
</p>
<hr  />
<p>
I claim that Alice is in the bar if and only if Alice's husband is on
the beach.
</p>

<p>
To see this, first suppose that Alice is in the bar.
</p>

<p>
Then &#x2026;
</p>

<p>
Hence Alice's husband is on the beach.
</p>

<p>
Conversely, suppose Alice's husband is on the beach.
</p>

<p>
Then &#x2026;
</p>

<p>
Hence Alice is in the bar.
</p>
<hr  />
<p>
Notice that with this example, we have varied the form of
presentation, stating the conclusion first, rather than at the end of
the argument. This kind of "signposting" is common in informal
arguments, in that is helps guide the reader's expectations and
foreshadow where the argument is going. The fact that formal systems
of deduction do not generally model such nuances marks a difference
between formal and informal arguments, a topic we will return to
below.
</p>

<p>
The introduction is modeled in natural deduction as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_58498e8c4935101dfde0f9dab110955b8bbae718.png" alt="\begin{center}
\AXM{}
\UIM{A}
\noLine
\UIM{\vdots}
\noLine
\UIM{B}
\AXM{}
\UIM{B}
\noLine
\UIM{\vdots}
\noLine
\UIM{A}
\RL{$\liff \mathrm{I}$}
\BIM{A \liff B}
\DP
\end{center}
" /></p>
</div>
<p>
And here is in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : A ↔ B :=
iff.intro
  (assume H : A,
    show B, from sorry)
  (assume H : B,
    show A, from sorry)
</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>variables (A B : Prop)

example : A ↔ B :=
iff.intro
  (assume H : A,
    show B, from sorry)
  (assume H : B,
    show A, from sorry)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You enter the symbol <code>↔</code> by typing <code>\iff</code> or <code>\lr</code> (for the left-right
arrow). Notice that you can re-use the letter <code>H</code> for the hypothesis,
since the two branches of the proof are independent.
</p>

<p>
The elimination rules for iff are unexciting. In informal language,
here is the "left" rule:
</p>
<hr  />
<p>
Alice is in the bar if and only if Alice's husband is on the beach.
</p>

<p>
Alice is in the bar.
</p>

<p>
Hence, Alice's husband is on the beach.
</p>
<hr  />
<p>
The "right" rule simply runs in the opposite direction. 
</p>
<hr  />
<p>
Alice is in the bar if and only if Alice's husband is on the beach.
</p>

<p>
Alice's husband is on the beach.
</p>

<p>
Hence, Alice is in the bar.
</p>
<hr  />
<p>
Rendered in natural deduction, the rules are as follows:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_40cd30979abe5f135eb917fd59f473c9c88c1069.png" alt="\begin{center}
\AXM{A \liff B}
\AXM{A}
\RL{$\liff \mathrm{E}_l$}
\BIM{B}
\DP
\quad
\AXM{A \liff B}
\AXM{B}
\RL{$\liff \mathrm{E}_r$}
\BIM{A}
\DP
\end{center}
" /></p>
</div>
<p>
Lean defines the rules <code>iff.and_elim_left</code> and <code>iff.and_elim_right</code>,
but also provides the abbreviations <code>iff.mp</code> (for "modus ponens") and
<code>iff.mpr</code> (for modus ponens reverse).
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : B :=
have H₁ : A ↔ B, from sorry,
have H₂ : A, from sorry,
show B, from iff.mp H₁ H₂

example : A :=
have H₁ : A ↔ B, from sorry,
have H₂ : B, from sorry,
show A, from iff.mpr H₁ H₂
</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>variables (A B : Prop)

example : B :=
have H₁ : A ↔ B, from sorry,
have H₂ : A, from sorry,
show B, from iff.mp H₁ H₂

example : A :=
have H₁ : A ↔ B, from sorry,
have H₂ : B, from sorry,
show A, from iff.mpr H₁ H₂
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8"><span class="section-number-4"> 2.3.6</span> Proof by Contradiction</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
We saw an example of an informal argument that implictly uses the
introduction rule for negation:
</p>
<hr  />
<p>
Suppose Alice's husband was in the bar. 
</p>

<p>
&#x2026;
</p>

<p>
This situation is impossible. 
</p>

<p>
Therefore Alice's husband was not in the bar.
</p>
<hr  />
<p>
Consider the following argument:
</p>
<hr  />
<p>
Suppose Alice's husband was not on the beach.
</p>

<p>
&#x2026;
</p>

<p>
This situation is impossible.
</p>

<p>
Therefore Alice's husband was on the beach.
</p>
<hr  />
<p>
At first glance, you might think this argument follows the same
pattern as the one before. But a closer look should reveal a
difference: in the first argument, a negation is <i>introduced</i> into the
conclusion, whereas in the second, it is <i>eliminated</i> from the
hypothesis. Using negation introduction to close the second argument
would yield the conclusion "It is not the case that Alice's husband
was not on the beach." The rule of inference that replaces the
conclusion with the positive statement that Alice's husband <i>was</i> on
the beach is called a <i>proof by contradiction</i>. (It also has a fancy
name, <i>reductio ad absurdum</i>, "reduction to an absurdity.")
</p>

<p>
It may be hard to see the difference between the two rules, because we
commonly take the statement "Alice's husband was not not on the beach"
to be a roundabout and borderline ungrammatical way of saying that
Alice's husband was on the beach. Indeed, the rule is equivalent to
adding an axiom that says that for every statement A, "not not A" is
equivalent to A.
</p>

<p>
There is a style of doing mathematics known as "constructive
mathematics" that denies the equivalence of "not not A" and
A. Constructive arguments tend to have much better computational
interpretations; a proof that something is true should provide
explicit evidence that the statement is true, rather than evidence
that it can't possibly be false. We will discuss constructive
reasoning in a later chapter. Nonetheless, proof by contradiction is
used extensively in contemporary mathematics, and so, in the
meanwhile, we will use proof by contradiction freely as one of our
basic rules.
</p>

<p>
In natural deduction, proof by contradiction is expressed by the
following pattern:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_d7962edea8ccf7a3086991f88239dad82ca91369.png" alt="\begin{prooftree}
\AXM{}
\UIM{\neg A}
\noLine
\UIM{\vdots}
\noLine
\UIM{\bot}
\UIM{A}
\end{prooftree}
" /></p>
</div>
<p>
The assumption <img src="ltxpng/02_Propositional_Logic.org.temp_c9fc0b9f87a04276e5274737b465662205a69233.png" alt="$\neg A$" /> is canceled at the final inference. 
</p>

<p>
In Lean, the inference is named <code>by_contradiction</code>, and since it is a
classical rule, we have to use the command <code>open classical</code> before it
is available. Once we do so, the pattern of inference is expressed as
follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">open classical

variable (A : Prop)

example : A :=
by_contradiction
  (assume H : ¬ A,
    show false, from sorry)
</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>open classical

variable (A : Prop)

example : A :=
by_contradiction
  (assume H : ¬ A,
    show false, from sorry)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3"> 2.4</span> Writing Proofs in Natural Deduction</h3>
<div class="outline-text-3" id="text-1-4">
<p>
As noted in Chapter <a href="#" onclick="myModule.loadTutorial('01_Introduction.html', 'MissingReference')">Introduction</a>, there are two common styles for
writing natural deduction derivations. (The word "derivation" is often
used to connote a formal proof instead of an informal one. When
talking about natural deduction, we will use the words "derivation"
and "proof" interchangeably.) In both cases, proofs are presented on
paper as trees, with the conclusion at the theorem at the root, and
hypotheses up at the leaves. In the first style of presentation, the
set of hypotheses is written explicitly at every node of the
tree. This is helpful because some rules (namely, implication
introduction, negation introduction, or elimination, and proof by
contradiction) change the set of hypotheses, by canceling a local or
temporary assumption. Nonetheless, we will use a style of presentation
that leaves this information implicit, so that each node of the tree
is labelled with an explicit formula. Some people like to label each
inference with the rule that is used, but that is usually clear from
the context, so we will omit that as well. But when a rule cancels a
hypothesis, we will make that clear in the following way: we will
label all instances of the hypothesis at the leaves with a letter,
like "x," and then we will use that letter to annotate the place where
the rule is canceled.
</p>

<p>
When writing expressions in symbolic logic, we will adopt the an order
of operations, which allow us to drop superfluous parentheses. When
parsing an expression:
</p>
<ul class="org-ul">
<li>negation binds most tightly</li>
<li>then conjunctions and disjunctions, from right to left</li>
<li>and finally implications and bi-implications.</li>
</ul>
<p>
So, for example, the expression <img src="ltxpng/02_Propositional_Logic.org.temp_ace3b80f722e8c2d279d113e8832219bed35dd64.png" alt="$\neg A \vee B \to C \wedge D$" /> is
understood as <img src="ltxpng/02_Propositional_Logic.org.temp_e22bf21dac5de9df570744886f83a72f05a6b736.png" alt="$((\neg A) \vee B) \to (C \wedge D)$" />
</p>

<p>
In addition to the rules listed in the last section, there is one
additional rule that is central to the system, namely the assumption
rule. It works like this: at any point, you can assume a hypothesis,
<img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />. The way to read such a one-line proof is this: assuming <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />, we
have proved <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />. Without this rule, there would be no way of getting a
proof off the ground! After all, every rule listed in the last section
has premises, which is to say, it can only be applied to derivations
that have been constructed previously.
</p>

<p>
Let us consider a few examples. In each case, you should think about
what the formulas say and which rule of inference is invoked at each
step. Also pay close attention to which hypotheses are canceled at
each stage. If you look at any node of the tree, what has been
established at that point is that the claim follows from the
uncanceled hypotheses. Here is a proof of <img src="ltxpng/02_Propositional_Logic.org.temp_37ccc10ed2338ea3dca6f49bd8ac285548842fb4.png" alt="$A \wedge (B \vee C) \to
(A \wedge B) \vee (A \wedge C)$" />:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_f8b2cc707e139e4a1e14fd8766d5972b29026f6c.png" alt="\begin{prooftree}
\AXM{}
\UIM{y : A \wedge (B \vee C)}
\UIM{B \vee C}
\AXM{}
\UIM{y : A \wedge (B \vee C)}
\UIM{A}
\AXM{}
\UIM{x : B}
\BIM{A \wedge B}
\UIM{(A \wedge B) \vee (A \wedge C)}
\AXM{}
\UIM{y : A \wedge (B \vee C)}
\UIM{A}
\AXM{}
\UIM{x : C}
\BIM{A \wedge C}
\UIM{(A \wedge B) \vee (A \wedge C)}
\RLM{x}
\TIM{(A \wedge B) \vee (A \wedge C)}
\RLM{y}
\UIM{(A \wedge (B \vee C)) \to ((A \wedge B) \vee
  (A \wedge C))}
\end{prooftree}
" /></p>
</div>

<p>
There is a general heuristic for proving theorems in natural deduction:
</p>
<ol class="org-ol">
<li>First, work backwards from the conclusion, using the introduction
rules. For example, if you are trying to prove a statement of the
form <img src="ltxpng/02_Propositional_Logic.org.temp_3a9090234befeadc30f2545de2a44cc4fe6badf4.png" alt="$A \to B$" />, add <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> to your list of hypotheses and try to
derive <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />. If you are trying to prove a statement of the form <img src="ltxpng/02_Propositional_Logic.org.temp_be31c611b4efedbbae42e918c199920ff2338806.png" alt="$A
   \wedge B$" />, use the and-introduction rule to reduce your task to
proving <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />, and then proving <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />.</li>
<li>When you have run out things to do in the first step, use
elimination rules to work forwards. If you have hypotheses <img src="ltxpng/02_Propositional_Logic.org.temp_7fc9f96fc7f04ae5bca5f99e10971c2a7578aa45.png" alt="$A \to
   B$" /> and <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />, apply modus ponens to derive <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />. If you have a
hypothesis <img src="ltxpng/02_Propositional_Logic.org.temp_454a2b03e9bbd58443ca50360be2588e72d2d909.png" alt="$A \vee B$" />, use or elimination and try to prove any open
goals by splitting on cases, considering <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> in one case and <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> in
the other.</li>
<li>If all else fails, use a proof by contradiction.</li>
</ol>

<p>
The next proof shows that if a conclusion, <img src="ltxpng/02_Propositional_Logic.org.temp_d5420fe138f4d39b6f52f71250e99e0a36aaaab5.png" alt="$C$" />, follows from <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> and
<img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />, then it follows from their conjunction.
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_30cc88a8d5f5f5e45ca9836a9f3d95e42230422d.png" alt="\begin{prooftree}
\AXM{}
\RLM{y}
\UIM{A \to (B \to C)}
\AXM{}
\RLM{x}
\UIM{A \wedge B}
\UIM{A}
\BIM{B \to C}
\AXM{}
\RLM{x}
\UIM{A \wedge B}
\UIM{B}
\BIM{C}
\RLM{x}
\UIM{A \wedge B \to C}
\RLM{y}
\UIM{(A \to (B \to C)) \to
(A \wedge B \to C)}
\end{prooftree}
" /></p>
</div>
<p>
The conclusion of the next proof can be interpreted as saying that if
it is not the case that one of <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> or <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> is true, then they are both
false.
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_eed43b400206f7beca8fb4634903caadceef16d9.png" alt="\begin{prooftree}
\AXM{}
\RLM{z}
\UIM{\lnot(A \vee B)}
\AXM{}
\RLM{x}
\UIM{A}
\UIM{A \vee B}
\BIM{\bot}
\RLM{x}
\UIM{\lnot A}
\AXM{}
\RLM{z}
\UIM{\lnot(A \vee B)}
\AXM{}
\RLM{y}
\UIM{B}
\UIM{A \vee B}
\BIM{\bot}
\RLM{y}
\UIM{\lnot B}
\BIM{\lnot A \wedge \lnot B}
\RLM{z}
\UIM{\lnot(A \vee B) \to \lnot A \wedge \lnot B}
\end{prooftree}
" /></p>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3"> 2.5</span> Writing Proofs in Lean</h3>
<div class="outline-text-3" id="text-1-5">
<p>
We will see that Lean has mechanisms for modeling proofs at a higher
level than natural deduction derivations. At the same time, you can
also carry out low-level inferences, and carry out proofs that mirror
natural deduction proofs quite closely. Here is a Lean representation
of the first example in the previous section:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">variables (A B C : Prop)

example : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H₁ : A ∧ (B ∨ C),
have H₂ : A, from and.left H₁,
have H₃ : B ∨ C, from and.right H₁,
show (A ∧ B) ∨ (A ∧ C), from 
  or.elim H₃
    (assume H₄ : B,
      have H₅ : A ∧ B, from and.intro H₂ H₄,
      show (A ∧ B) ∨ (A ∧ C), from or.inl H₅)
    (assume H₄ : C,
      have H₅ : A ∧ C, from and.intro H₂ H₄,
      show (A ∧ B) ∨ (A ∧ C), from or.inr H₅)
</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>variables (A B C : Prop)

example : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H₁ : A ∧ (B ∨ C),
have H₂ : A, from and.left H₁,
have H₃ : B ∨ C, from and.right H₁,
show (A ∧ B) ∨ (A ∧ C), from 
  or.elim H₃
    (assume H₄ : B,
      have H₅ : A ∧ B, from and.intro H₂ H₄,
      show (A ∧ B) ∨ (A ∧ C), from or.inl H₅)
    (assume H₄ : C,
      have H₅ : A ∧ C, from and.intro H₂ H₄,
      show (A ∧ B) ∨ (A ∧ C), from or.inr H₅)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The first line declares propositional variables <code>A</code>, <code>B</code>, and <code>C</code>. The
line that begins with the keyword <code>example</code> declares the theorem to be
proved, and the notation <code>:=</code> indicates that the proof will
follow. The line breaks and indentation are only for the purposes of
readability; Lean would do just was well if the entire proof were
written as one run-on line.
</p>

<p>
Here are some additional notes:
</p>

<ul class="org-ul">
<li>It is often important to name a theorem for future proof. Lean
allows us to do that, using one of the keywords <code>theorem</code>, <code>lemma</code>,
<code>proposition</code>, <code>corollary</code>, followed by the name of the proof.</li>

<li>You can omit a label in a <code>have</code> statement. You can then refer to
that fact using the label <code>this</code>, until the next anonymoyus
<code>have</code>. Alternatively, at any point later in the proof, you can
refer to the fact by putting the assertion between backticks.</li>

<li>One can also omit the label in an <code>assumption</code> by using the keyword
<code>suppose</code> instead.</li>

<li>Rather than declare variables beforehand, you can declare them in
parentheses before the colon the marks the statemet of the theorem.</li>
</ul>

<p>
With these features, the previous proof can be written as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">theorem my_theorem (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H : A ∧ (B ∨ C),
have A, from and.left H,
have B ∨ C, from and.right H,
show (A ∧ B) ∨ (A ∧ C), from
  or.elim `B ∨ C`
    (suppose B,
      have A ∧ B, from and.intro `A` `B`,
      show (A ∧ B) ∨ (A ∧ C), from or.inl this)
    (suppose C,
      have A ∧ C, from and.intro `A` `C`,
      show (A ∧ B) ∨ (A ∧ C), from or.inr this)
</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>theorem my_theorem (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
assume H : A ∧ (B ∨ C),
have A, from and.left H,
have B ∨ C, from and.right H,
show (A ∧ B) ∨ (A ∧ C), from
  or.elim `B ∨ C`
    (suppose B,
      have A ∧ B, from and.intro `A` `B`,
      show (A ∧ B) ∨ (A ∧ C), from or.inl this)
    (suppose C,
      have A ∧ C, from and.intro `A` `C`,
      show (A ∧ B) ∨ (A ∧ C), from or.inr this)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In fact, such a presentation provides Lean with more information than
is really necessary to construct an axiomatic proof. The word <code>assume</code>
can be replaced by the symbol <code>λ</code>, assertions can be omitted from an
<code>assume</code> when they can be inferred from context, the justification of
a have statement can be inserted in places where the label was
otherwise used, and one can omit the <code>show</code> clauses, giving only the
justification. As a result, the previous proof can be written in an
extremely abbreviated form:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
λ H₁, or.elim (and.right H₁)
  (λ H₄, or.inl (and.intro (and.left H₁) H₄))
  (λ H₄, or.inr (and.intro (and.left H₁) H₄))
</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>example (A B C : Prop) : A ∧ (B ∨ C) → (A ∧ B) ∨ (A ∧ C) :=
λ H₁, or.elim (and.right H₁)
  (λ H₄, or.inl (and.intro (and.left H₁) H₄))
  (λ H₄, or.inr (and.intro (and.left H₁) H₄))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Such proofs tend to be hard to write, read, understand, maintain, and
debug. In this text, we will favor structure and readability over
brevity.
</p>

<p>
The next proof in the previous section can be rendered in Lean as
follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">variables (A B C : Prop)

example : (A → (B → C)) → (A ∧ B → C) :=
assume H₁ : A → B → C,
assume H₂ : A ∧ B,
show C, from H₁ (and.left H₂) (and.right H₂)
</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>variables (A B C : Prop)

example : (A → (B → C)) → (A ∧ B → C) :=
assume H₁ : A → B → C,
assume H₂ : A ∧ B,
show C, from H₁ (and.left H₂) (and.right H₂)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>
<p>
And the last proof can be rendered as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">variables (A B : Prop)

example : ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this,
have ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`
</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>variables (A B : Prop)

example : ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this,
have ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>

<p>
You can add comments to your proofs in two ways. First, any text after
a double-dash <code>--</code> until the end of a line is ignored by the Lean
processor. Second, any text between <code>/-</code> and <code>-/</code> denotes a block
comment, and is also ignored. You can nest block comments.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-20' mode="ace/mode/lean" readonly="true">/- This is a block comment.
   It can fill multiple lines. -/

example (A : Prop) : A → A :=
suppose A,         -- assume the antecedent
show A, from this  -- use the assuption to establish the conclusion
</juicy-ace-editor><div id='lean-full-code-20' style='display:none'>/- This is a block comment.
   It can fill multiple lines. -/

example (A : Prop) : A → A :=
suppose A,         -- assume the antecedent
show A, from this  -- use the assuption to establish the conclusion
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-20').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Notice that you can use <code>sorry</code> as a temporary placeholder while
writing proofs.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-21' mode="ace/mode/lean" readonly="true">example (A B : Prop) : A ∧ B → B ∧ A :=
assume H : A ∧ B,
have H1 : A, from and.left H,
have H2 : B, from and.right H,
show B ∧ A, from sorry
</juicy-ace-editor><div id='lean-full-code-21' style='display:none'>example (A B : Prop) : A ∧ B → B ∧ A :=
assume H : A ∧ B,
have H1 : A, from and.left H,
have H2 : B, from and.right H,
show B ∧ A, from sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-21').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This enables you to check the proof to make sure it is correct modulo
the <code>sorry</code>, before you go on to replace the <code>sorry</code> with an actual
proof.
</p>

<p>
Here is another useful trick: try replacing the <code>sorry</code> by an
underscore character, <code>_</code>. This asks the Lean parser to guess what
should go there, based on the context. In this case, Lean does not
succeed, and gives you error message when you try to check the
proof. But the error message is informative: it tells you what you
need to prove, and what is available in the context for you to use.
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3"> 2.6</span> Writing Informal Proofs</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Remember that one goal of this course is to teach you to write
ordinary (mathematical) proofs as well formal proofs in natural
deduction and formally verified proofs in Lean. The fact that natural
deduction and Lean's proof language are designed to model some aspects
of informal proof does <i>not</i> mean that your informal proofs should
look like natural deduction derivations or proofs in Lean! There are
important differences between formal languages and informal language
that you should keep in mind.
</p>

<p>
For one thing, ordinary proofs tend to favor words over symbols. Of
course, mathematics uses symbols all the time, but not in place of
words like "and" and "not"; you will rarely, if ever, see the symbols
<img src="ltxpng/02_Propositional_Logic.org.temp_943241f8b9ef5aeddf5ddd1a3d2c955095eb95ab.png" alt="$\wedge$" /> and <img src="ltxpng/02_Propositional_Logic.org.temp_75bef715537945d703b4766c0a0e8b9749c23828.png" alt="$\neg$" /> in a mathematics textbook, unless it is a textbook
specifically about logic.
</p>

<p>
Similarly, the structure of an informal proof is conveyed with
ordinary paragraphs and punctuation. Don't rely on pictorial diagrams,
line breaks, and indentation to convey the structure of a
proof. Rather, you should rely on literary devices like signposting
and foreshadowing. It is often helpful to present an outline of a
proof or the key ideas before delving into the details, and the
introductory sentence of a paragraph can help guide a reader's
expectations, just as it does in an expository essay.
</p>

<p>
Perhaps the biggest difference between informal proofs and formal
proofs is the level of detail. Informal proofs will often skip over
details that are taken to be "straightforward" or "obvious," devoting
more effort to spelling out inferences that are novel of unexpected.
</p>

<p>
Writing a good proof is like writing a good essay. To convince your
readers that the conclusion is correct, you have to get them to
understand the argument, without overwhelming them with unnecessary
details. It helps to have a specific audience in mind. Try speaking
the argument aloud to friends, roommates, and family members; if their
eyes glaze over, it is unreasonable to expect anonymous readers to do
better.
</p>

<p>
Perhaps the best way to learn to write good proofs is to <i>read</i> good
proofs, and pay attention to the style of writing. Pick an example of
a textbook that you find especially clear and engaging, and think
about what makes it so. 
</p>

<p>
Natural deduction and formal verification can help you understand the
components that make a proof <i>correct</i>, but you will have to develop
an intuitive feel for what makes a proof easy and enjoyable to read.
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3"> 2.7</span> Theorems and Derived Rules</h3>
<div class="outline-text-3" id="text-1-7">
<p>
In the examples above, we showed that, given <img src="ltxpng/02_Propositional_Logic.org.temp_454a2b03e9bbd58443ca50360be2588e72d2d909.png" alt="$A \vee B$" /> and <img src="ltxpng/02_Propositional_Logic.org.temp_c9fc0b9f87a04276e5274737b465662205a69233.png" alt="$\neg A$" />,
we can derive <img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" /> in natural deduction. This is a common pattern of
inference, and, having justified it once, you might reasonably want to
use it freely as a new one-step inference. Similarly, having proved <img src="ltxpng/02_Propositional_Logic.org.temp_35693d56cafba26767dfd32f68fdcf7cbdea19cb.png" alt="$A
\to B$" /> equivalent to <img src="ltxpng/02_Propositional_Logic.org.temp_6581c5cc6ec29087c217297d610fff2f401c9596.png" alt="$\neg A \vee B$" />, or <img src="ltxpng/02_Propositional_Logic.org.temp_15b57da155bd200da977f355320d65d985c35b6e.png" alt="$\neg (A \vee B)$" /> equivalent
to <img src="ltxpng/02_Propositional_Logic.org.temp_ead4c4fd3d650a492a33f2d0c7a926ea8ecba594.png" alt="$\neg A \wedge \neg B$" />, one might feel justified in replacing one
by the other in any expression.
</p>

<p>
Indeed, this is how informal mathematics works: we start with basic
patterns of inference, but over time we learn to recognize more
complex patterns, and begin to apply them freely in our proofs. A
single step in the informal argument in the solution to "Malice and
Alice," or any mathematical proof, usually requires many more steps to
spell out in a formal calculus. Moreover, in ordinary mathematics, one
we prove a proposition or theorem, we can freely invoke it in another
proof later on.
</p>

<p>
One can extend natural deduction with various mechanisms to abbreviate
such "derived rules." We will not do so here, however. Natural
deduction is designed to model the low-level mechanics of a proof and
let us reason about deduction "from the outside"; we will not use it
to write long proofs.
</p>

<p>
In formal verification, however, the goal is to build complex proofs,
developing libraries for formalized mathematics along the way. To that
end, Lean allows you to name the theorems you prove:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-22' mode="ace/mode/lean" readonly="true">theorem not_and_not_of_not_or (A B : Prop) : 
  ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this,
have ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`
</juicy-ace-editor><div id='lean-full-code-22' style='display:none'>theorem not_and_not_of_not_or (A B : Prop) : 
  ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this,
have ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-22').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here we follow the convention of describing the conclusion of the
theorem first (<code>not_and_not</code>), followed by the hypotheses (in this
case, <code>not_or</code>), separated by <code>of</code>. Thereafter, we can use the theorem
as a new rule of inference:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-23' mode="ace/mode/lean" readonly="true">variables (C D : Prop)

example : ¬ (C ∨ D) → ¬ C ∧ ¬ D :=
assume H : ¬ (C ∨ D),
show ¬ C ∧ ¬ D, from not_and_not_of_not_or C D H</juicy-ace-editor><div id='lean-full-code-23' style='display:none'>theorem not_and_not_of_not_or (A B : Prop) : 
  ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this,
have ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`

variables (C D : Prop)

example : ¬ (C ∨ D) → ¬ C ∧ ¬ D :=
assume H : ¬ (C ∨ D),
show ¬ C ∧ ¬ D, from not_and_not_of_not_or C D H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-23').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that <code>not_and_not_of_not_or</code> takes, as arguments, the two
propositions <code>C</code> and <code>D</code> to which we want to instantiate the theorem,
followed by the hypothesis <code>H</code>. 
</p>

<p>
We can tell Lean to make the first two arguments implicit, by changing
<code>(A B : Prop)</code> to <code>{A B : Prop}</code>. The curly braces ask Lean to infer
the values of these arguments from the context. With that change, we
can write the preceding proof as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-24' mode="ace/mode/lean" readonly="true">variables (C D : Prop)

example : ¬ (C ∨ D) → ¬ C ∧ ¬ D :=
assume H : ¬ (C ∨ D),
show ¬ C ∧ ¬ D, from not_and_not_of_not_or H</juicy-ace-editor><div id='lean-full-code-24' style='display:none'>theorem not_and_not_of_not_or {A B : Prop} : 
  ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this,
have ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`

variables (C D : Prop)

example : ¬ (C ∨ D) → ¬ C ∧ ¬ D :=
assume H : ¬ (C ∨ D),
show ¬ C ∧ ¬ D, from not_and_not_of_not_or H
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-24').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here is a more interesting example: first we show, independently, that
each of <code>¬ A</code> and <code>¬ B</code> follows from <code>¬ (A ∨ B)</code>, and then we use
these facts to prove <code>not_and_not_of_not_or</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-25' mode="ace/mode/lean" readonly="true">variables {A B : Prop}

theorem not_of_not_or_left : ¬ (A ∨ B) → ¬ A :=
assume H : ¬ (A ∨ B),
show ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this

theorem not_of_not_or_right : ¬ (A ∨ B) → ¬ B :=
assume H : ¬ (A ∨ B),
show ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this

theorem not_and_not_of_not_or : ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from not_of_not_or_left H,
have ¬ B, from not_of_not_or_right H,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`
</juicy-ace-editor><div id='lean-full-code-25' style='display:none'>variables {A B : Prop}

theorem not_of_not_or_left : ¬ (A ∨ B) → ¬ A :=
assume H : ¬ (A ∨ B),
show ¬ A, from
  suppose A,
  have A ∨ B, from or.inl `A`,
  show false, from H this

theorem not_of_not_or_right : ¬ (A ∨ B) → ¬ B :=
assume H : ¬ (A ∨ B),
show ¬ B, from
  suppose B,
  have A ∨ B, from or.inr `B`,
  show false, from H this

theorem not_and_not_of_not_or : ¬ (A ∨ B) → ¬ A ∧ ¬ B :=
assume H : ¬ (A ∨ B),
have ¬ A, from not_of_not_or_left H,
have ¬ B, from not_of_not_or_right H,
show ¬ A ∧ ¬ B, from and.intro `¬ A` `¬ B`
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-25').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Later, we will see that Lean has an expansive library of theorems.
Eventually, Lean will also have automation that will fill in small
steps automatically. In elementary exercises, however, we will expect
you to carry out such proofs by hand.
</p>

<p>
To summarize our expectations in this course:
</p>

<ul class="org-ul">
<li>When we ask you to prove something in natural deduction, our goal
is to make you work with the precise, formal rules of the
system, so you should not appeal to external rules unless we
explicitly say you can.</li>

<li>In interactive theorem proving, the main goal is to have the
computer certify the proof as correct, and in that respect,
automation and facts from the library are fair game. To learn to
use the system, however, it is helpful to prove elementary theorems
by hand. In this class, we will try to be explicit about what we
would like you to use in the exercises we assign.</li>

<li>When writing informal proofs, it is a judgment call as to what
prior patterns of reasoning and background facts you may appeal
to. In a classroom setting, the goal may be to demonstrate mastery
of the subject to the instructors, in which case, context should
dictate what is allowable (and it is always a good idea to err on
the side of caution). In real life, your goal is to convince your
target audience, and you will have to rely on convention and
experience to judge what patterns of inference you can put forth,
and how much detail you need to use.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="Classical_Reasoning"><a id="orgheadline14"></a><span class="section-number-3"> 2.8</span> Classical Reasoning</h3>
<div class="outline-text-3" id="text-Classical_Reasoning">
<p>
In informal mathematics, it is usually clearer to give a "direct"
proof of a theorem, rather than using proof by contradiction. But
proof by contradiction is sometimes necessary, and, at a foundational
level, it can be used to derive other classical patterns of reasoning.
</p>

<p>
For example, we have seen that if you know <img src="ltxpng/02_Propositional_Logic.org.temp_454a2b03e9bbd58443ca50360be2588e72d2d909.png" alt="$A \vee B$" />, you can use
that knowledge to reason on cases, assuming first <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" />, and then
<img src="ltxpng/02_Propositional_Logic.org.temp_d97dc406cb5606cb9d7e849c11adc553d50b79a6.png" alt="$B$" />. In mathematical arguments, however, one often splits a proof into
two cases, assuming first <img src="ltxpng/02_Propositional_Logic.org.temp_cfd84d0cf5b16a0279ed47d0d5204f0d029e1098.png" alt="$A$" /> and then <img src="ltxpng/02_Propositional_Logic.org.temp_c9fc0b9f87a04276e5274737b465662205a69233.png" alt="$\neg A$" />. Using the elimination
rule for disjunction, this is equivalent to using <img src="ltxpng/02_Propositional_Logic.org.temp_648f455393860e148fb987e1e4bdf6b4da52b1b1.png" alt="$A \vee \neg A$" />, a
classical principle known as the law of the excluded middle. Here is a
proof of this, in natural deduction, using a proof by contradiction:
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_736ad9ebfbef4bbf04a38660b4e43b20f39559d1.png" alt="\begin{prooftree}
\AXM{}
\RLM{y}
\UIM{\neg (A \vee \neg A)}
\AXM{}
\RLM{x}
\UIM{A}
\UIM{A \vee \neg A}
\BIM{\bot}
\RLM{x}
\UIM{\neg A}
\UIM{A \vee \neg A}
\AXM{}
\RLM{x}
\UIM{\neg (A \vee \neg A)}
\BIM{\bot}
\RLM{y}
\UIM{A \vee \neg A}
\end{prooftree}
" /></p>
</div>
<p>
Here is the same proof rendered in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-26' mode="ace/mode/lean" readonly="true">open classical

variable (A : Prop)

example : A ∨ ¬ A :=
by_contradiction
  (assume H : ¬ (A ∨ ¬ A),
    have ¬ A, from
      suppose A,
      have A ∨ ¬ A, from or.inl this,
      show false, from H this,
    have A ∨ ¬ A, from or.inr `¬ A`,
    show false, from H this)
</juicy-ace-editor><div id='lean-full-code-26' style='display:none'>open classical

variable (A : Prop)

example : A ∨ ¬ A :=
by_contradiction
  (assume H : ¬ (A ∨ ¬ A),
    have ¬ A, from
      suppose A,
      have A ∨ ¬ A, from or.inl this,
      show false, from H this,
    have A ∨ ¬ A, from or.inr `¬ A`,
    show false, from H this)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-26').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The principle is known as the law of the excluded middle because it
says that a proposition <code>A</code> is either true or false; there is no
middle ground. As a result, the theorem is named <code>em</code> in the Lean
library. For any proposition <code>A</code>, <code>em A</code> denotes a proof of <code>A ∨ ¬ A</code>,
and you are free to use it any time <code>classical</code> is open:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-27' mode="ace/mode/lean" readonly="true">open classical

example (A : Prop) : A ∨ ¬ A :=
or.elim (em A)
  (suppose A, or.inl this)
  (suppose ¬ A, or.inr this)
</juicy-ace-editor><div id='lean-full-code-27' style='display:none'>open classical

example (A : Prop) : A ∨ ¬ A :=
or.elim (em A)
  (suppose A, or.inl this)
  (suppose ¬ A, or.inr this)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-27').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Or even more simply:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-28' mode="ace/mode/lean" readonly="true">open classical

example (A : Prop) : A ∨ ¬ A :=
em A
</juicy-ace-editor><div id='lean-full-code-28' style='display:none'>open classical

example (A : Prop) : A ∨ ¬ A :=
em A
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-28').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Here is another example. Intuitively, asserting "if A then B" is
equivalent to saying that it cannot be the case that A is true and B
is false. Classical reasoning is needed to get us from the second
statement to the first.
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_287ca672b8fe9f18e9066e74b089895781482abc.png" alt="\begin{prooftree}
  \AXM{}
  \RLM{z}
  \UIM{\lnot (A \wedge \neg B)}
  \AXM{}
  \RLM{y}
  \UIM{A}
  \AXM{}
  \RLM{x}
  \UIM{\neg B}
  \BIM{A \wedge \neg B}
  \BIM{\bot}
  \RLM{x}
  \UIM{B}
  \RLM{y}
  \UIM{A \to B}
  \RLM{z}
  \UIM{\neg (A \wedge \neg B) \to (A \to B)}
\end{prooftree}
" /></p>
</div>
<p>
Here is the same proof, rendered in Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-29' mode="ace/mode/lean" readonly="true">open classical

variables (A B : Prop)

example (H : ¬ (A ∧ ¬ B)) : A → B :=
suppose A,
show B, from
  by_contradiction
    (suppose ¬ B,
      have A ∧ ¬ B, from and.intro `A` this,
      show false, from H this)
</juicy-ace-editor><div id='lean-full-code-29' style='display:none'>open classical

variables (A B : Prop)

example (H : ¬ (A ∧ ¬ B)) : A → B :=
suppose A,
show B, from
  by_contradiction
    (suppose ¬ B,
      have A ∧ ¬ B, from and.intro `A` this,
      show false, from H this)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-29').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3"> 2.9</span> Some Logical Identities</h3>
<div class="outline-text-3" id="text-1-9">
<p>
For reference, the following is a list of commonly used propositional
equivalences.
</p>

<div class="figure">
<p><img src="ltxpng/02_Propositional_Logic.org.temp_6c7dbe053cd870a774e7dd5e619f78ebb660f43c.png" alt="\begin{enumerate}
\item Commutativity of $\wedge$: $A \wedge B \liff B \wedge A$
\item Commutativity of $\vee$: $A \vee B \liff B \vee A$
\item Associativity of $\wedge$: $(A \wedge B) \wedge C \liff
      A \wedge (B \wedge C)$
\item Associativity of $\vee$: $(A \vee B) \vee C \liff
      A \vee (B \vee C)$
\item Distributivity of $\wedge$ over $\vee$: $A \wedge (B \vee C) \liff 
      (A \wedge B) \vee (A \wedge C)$
\item Distributivity of $\vee$ over $\wedge$: $A \vee (B \wedge C) \liff 
      (A \vee B) \wedge (A \vee C)$
\item $(A \to (B \to C)) \liff (A \wedge B \to C)$.
\item $(A \to B) \to ((B \to C) \to (A \to C))$
\item $((A \vee B) \to C) \liff (A \to C) \wedge (B \to C)$
\item $\lnot (A \vee B) \liff \lnot A \wedge \lnot B$
\item $\lnot (A \wedge B) \liff \lnot A \vee \lnot B$
\item $\lnot (A \wedge \lnot A)$
\item $\lnot (A \to B) \liff A \wedge \lnot B$
\item $\lnot A \to (A \to B)$
\item $(\lnot A \vee B) \liff (A \to B)$
\item $A \vee \bot \liff A$
\item $A \wedge \bot \liff \bot$
\item $A \vee \lnot A$
\item $\lnot (A \liff \lnot A)$
\item $(A \to B) \liff (\lnot B \to \lnot A)$
\item $(A \to C \vee D) \to ((A \to C) \vee (A \to D))$
\item $(((A \to B) \to A) \to A)$
\end{enumerate}
" /></p>
</div>
<p>
All of them can be derived in natural deduction, and in Lean, using
the rules and patterns of inference discussed in this Chapter.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
